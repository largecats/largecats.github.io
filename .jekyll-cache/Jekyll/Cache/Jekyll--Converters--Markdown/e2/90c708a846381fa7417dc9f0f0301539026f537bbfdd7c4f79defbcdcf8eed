I"
x<ul id="markdown-toc">
  <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
  <li><a href="#preparation" id="markdown-toc-preparation">Preparation</a></li>
  <li><a href="#method" id="markdown-toc-method">Method</a>    <ul>
      <li><a href="#ocr-with-tesseract" id="markdown-toc-ocr-with-tesseract">OCR with Tesseract</a></li>
      <li><a href="#image-processing-with-opencv" id="markdown-toc-image-processing-with-opencv">Image processing with OpenCV</a>        <ul>
          <li><a href="#detecting-speech-bubbles" id="markdown-toc-detecting-speech-bubbles">Detecting speech bubbles</a></li>
          <li><a href="#feeding-speech-bubbles-to-tesseract" id="markdown-toc-feeding-speech-bubbles-to-tesseract">Feeding speech bubbles to Tesseract</a></li>
          <li><a href="#file-io" id="markdown-toc-file-io">File I/O</a></li>
          <li><a href="#main-loop" id="markdown-toc-main-loop">Main loop</a></li>
        </ul>
      </li>
      <li><a href="#result" id="markdown-toc-result">Result</a></li>
    </ul>
  </li>
</ul>

<h2 id="motivation">Motivation</h2>

<p>I came across <a href="https://www.youtube.com/watch?v=1LBFR90f6rg">this motion comic</a> (click <a href="https://www.bilibili.com/video/av2786047">here</a> for the video if the link does not work) based on issue 16 of the IDW comic <em>The Transformers: More than Meets the Eye</em> (click <a href="https://www.transformers.kiev.ua/index.php?pageid=idw">here</a> to view the comic in Russian or English and <a href="http://www.tfg2.com/read.php?tid-45122.html">here</a> to view in Chinese).</p>

<p>In the motion comic, a video message is composed by putting together footage from various videos. I wanted to do the same with the image dimension, i.e., compose an image message by putting together various cropped images from the comics in a Montage-ish manner, as shown below. To read the message, just read off the speech bubbles in each image from left to right and top to down.</p>

<div style="text-align: center"><img src="/images/rewind-message.png" width="800px" /></div>
<div align="center">
<sup>Page 18-19 of The Transformers: More than Meets the Eye #16.</sup>
</div>

<h2 id="preparation">Preparation</h2>

<p>I read <a href="https://www.pyimagesearch.com/2017/07/10/using-tesseract-ocr-python/">this article</a> about the OCR engine Tesseract and <a href="https://docs.opencv.org/3.3.0/d7/d4d/tutorial_py_thresholding.html">this one</a> about OpenCV.</p>

<h2 id="method">Method</h2>

<p>Suppose we have a text message and a folder of comic images. To compose the image message, for each word in the text message, we need to find a comic page with a text bubble that contains that word, crop it, and put all the cropped images together. Cropping and putting the cropped images together are steps that can be done manually in photoshop in a reasonably straightforward manner. The step that is not a reasonable manual task is finding a comic page that contains a certain word. This is where optical character recognition (OCR) comes in.</p>

<p>OCR is the conversion of images of text into machine-encoded text. We will use it to extract text from the comics’ speech bubbles. We can then store the text along with the paths of the corresponding comic pages to make a text-path dictionary. In this way, when we need a comic page that contains a certain word, we can simply search for the word in this dictionary and look up the path of the comic page that contains it. E.g., with the following dictionary, if we need the word “machine”, searching for it would lead us to line 3, and we would know to view the comic page at <code class="language-plaintext highlighter-rouge">C:/comics/issue01/page02.jpg</code>.</p>

<table>
  <thead>
    <tr>
      <th>path</th>
      <th>text</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>C:/comics/issue01/page01.jpg</td>
      <td>I DON’T LIKE IT…</td>
    </tr>
    <tr>
      <td>C:/comics/issue01/page01.jpg</td>
      <td>CAN’T WE JUST PUSH A BUTTON AND BE DONE WITH IT?</td>
    </tr>
    <tr>
      <td>C:/comics/issue01/page02.jpg</td>
      <td>EACH A COG IN THE GREAT MACHINE.</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<p>All code can be found <a href="https://github.com/largecats/comics-ocr">here</a>.</p>

<h3 id="ocr-with-tesseract">OCR with Tesseract</h3>

<p>For the above purpose, we will use the OCR engine <a href="https://github.com/tesseract-ocr/tesseract">Tesseract</a>.</p>

<ol>
  <li>Download Tesseract from <a href="https://github.com/tesseract-ocr/tessdoc/blob/master/Home.md">here</a>.</li>
  <li>Add the path of installation, e.g., <code class="language-plaintext highlighter-rouge">C:\Program Files (x86)\Tesseract-OCR</code>, to environment variables.</li>
  <li>
    <p>Open cmd and type <code class="language-plaintext highlighter-rouge">tesseract -v</code>. If the version information shows up, the installation is successful. E.g.,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> C:\Users\largecats&gt;tesseract -v
 tesseract 3.05.01
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="image-processing-with-opencv">Image processing with OpenCV</h3>

<p>Tesseract works best with images of text with clean background. Since a comic page contains image and text, it does not make sense to pass the entire page to Tesseract and expect it to recognize the text scattered in speech bubbles. Thus, we need to preprocess the comic page, isolate the candidate speech bubbles, crop them from the comic page, and feed each cropped speech bubble candidate to Tesseract for character recognition.</p>

<p>We begin by importing the necessary modules.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">pytesseract</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">csv</span>
</code></pre></div></div>

<h4 id="detecting-speech-bubbles">Detecting speech bubbles</h4>

<p>First of all, we need to find all (or as many as possible) speech bubbles in a given comic page. Luckily, speech bubbles usually have relatively well-defined edges and mostly rectangular shapes. To exploit these properties in detecting speech bubbles, we use the <code class="language-plaintext highlighter-rouge">findContours()</code> function from <code class="language-plaintext highlighter-rouge">cv2</code> to recognize edges in the comic page and bound them using rectangles (<code class="language-plaintext highlighter-rouge">boundingRect()</code>), which would then become the speech bubble candidates. As shown below, <code class="language-plaintext highlighter-rouge">findContours()</code> picks up a lot of noise that are not speech bubbles.</p>

<div style="text-align: center"><img src="/images/all_rectangles.png" width="450px" /></div>
<div align="center">
<sup>Page 01 of Transformers: Megatron Origin #1 with speech bubble candidates (in green) before filtering.</sup>
</div>

<p>Luckily, speech bubbles have a small range of sizes. Thus, we can filter out the candidates that are unlikely to be speech bubbles because they are either too large or too small, as shown below.</p>

<div style="text-align: center"><img src="/images/filtered_rectangles.png" width="450px" /></div>
<div align="center">
<sup>Page 01 of Transformers: Megatron Origin #1 with speech bubble candidates (in green) after filtering.</sup>
</div>

<p>To help with contour detection, before the steps above, we turn the image into gray scale, filter out noise, and add some filters to make the edges sharper. For convenice, we define the following function to do all the above. The function returns a list of candidate speech bubbles as images.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># find all speech bubbles in the given comic page and return a list of cropped speech bubbles (with possible false positives)
</span><span class="k">def</span> <span class="nf">findSpeechBubbles</span><span class="p">(</span><span class="n">imagePath</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">'simple'</span><span class="p">):</span>
    <span class="c1"># read image
</span>    <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">imagePath</span><span class="p">)</span>
    <span class="c1"># gray scale
</span>    <span class="n">imageGray</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
    <span class="c1"># filter noise
</span>    <span class="n">imageGrayBlur</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">imageGray</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s">'simple'</span><span class="p">:</span>
        <span class="c1"># recognizes more complex bubble shapes
</span>        <span class="n">imageGrayBlurCanny</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">imageGrayBlur</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">imageGrayBlurCanny</span><span class="p">,</span><span class="mi">235</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="n">cv2</span><span class="p">.</span><span class="n">THRESH_BINARY</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># recognizes only rectangular bubbles
</span>        <span class="n">binary</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">imageGrayBlur</span><span class="p">,</span><span class="mi">235</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="n">cv2</span><span class="p">.</span><span class="n">THRESH_BINARY</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># find contours
</span>    <span class="n">contours</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span><span class="n">cv2</span><span class="p">.</span><span class="n">RETR_TREE</span><span class="p">,</span><span class="n">cv2</span><span class="p">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># get the list of cropped speech bubbles
</span>    <span class="n">croppedImageList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">boundingRect</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
        <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">rect</span>
        <span class="c1"># filter out speech bubble candidates with unreasonable size
</span>        <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">500</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">60</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">500</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">:</span>
            <span class="n">croppedImage</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">+</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">w</span><span class="p">]</span>
            <span class="n">croppedImageList</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">croppedImage</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">croppedImageList</span>
</code></pre></div></div>
<p>Somehow, images cropped this way (via the <code class="language-plaintext highlighter-rouge">image[y:y+h, x:x+w]</code> syntax) are not as good for OCR as images cropped using external programs, such as QQ. But I did not figure out a way to use external programs to crop the images and feed it to the OCR engine, so this would have to be a game of another day.</p>

<h4 id="feeding-speech-bubbles-to-tesseract">Feeding speech bubbles to Tesseract</h4>

<p>Now, suppose we have a speech bubble candidate. We need to feed it to Tesseract for (English) character recognition. <code class="language-plaintext highlighter-rouge">pytesseract.image_to_string()</code> returns the recognized characters as a string. We filter for characters that do show up in the comics.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># apply the ocr engine to the given image and return the recognized script where illegitimate characters are filtered out
</span><span class="k">def</span> <span class="nf">tesseract</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">script</span> <span class="o">=</span> <span class="n">pytesseract</span><span class="p">.</span><span class="n">image_to_string</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lang</span> <span class="o">=</span> <span class="s">'eng'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">script</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s">' -QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm,.?!1234567890"":;</span><span class="se">\'</span><span class="s">'</span><span class="p">:</span>
            <span class="n">script</span> <span class="o">=</span> <span class="n">script</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">char</span><span class="p">,</span><span class="s">''</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">script</span>
</code></pre></div></div>
<p>The script produced by Tesseract from the comic page above is as follows.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I DONT LIKE IT...
"THE LAW 54? THISSORT 0F THING HA6 TOBE DECLARE? ON-GITE.FORrMLTIEG.
I DONT HNDERSTAND WHYWE HAVE TO BE HERE. CANTWE JNST... PUSH A BHTTONAND BE DONE WITH IT?
MINING OUTPOST C-12.
LONG AGO. PEACETMIE.
THE CYBERTQON SYSTEM.1
</code></pre></div></div>
<p>The character recognition is not perfect, but acceptable.</p>

<h4 id="file-io">File I/O</h4>

<p>We define the following helper functions. <code class="language-plaintext highlighter-rouge">looper()</code> loops through the root directory that contains the comics and returns a list of paths of the comic pages. Ideally the root directory should have a structure like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root
+-- issue01
    +-- page01.jpg
    +-- page02.jpg
    +-- ...
+-- issue02
    +-- page01.jpg
    +-- page02.jpg
    +-- ...
...
</code></pre></div></div>
<p>Note that the code only picks up <code class="language-plaintext highlighter-rouge">.jpg</code>, <code class="language-plaintext highlighter-rouge">.png</code>, and <code class="language-plaintext highlighter-rouge">.bmp</code> files from (folders and subfolders of) the root directory. <code class="language-plaintext highlighter-rouge">write_script_to_csv()</code>writes the detected comic script along with the path of the corresponding comic page to a <code class="language-plaintext highlighter-rouge">.csv</code> file.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># loop through each file in the given directory, not including zip files
</span><span class="k">def</span> <span class="nf">looper</span><span class="p">(</span><span class="n">rootDir</span><span class="p">):</span>
    <span class="n">fileNameList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">filePathList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subDir</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="p">.</span><span class="n">walk</span><span class="p">(</span><span class="n">rootDir</span><span class="p">):</span>
        <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="n">fileInfo</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'.'</span><span class="p">)</span>
            <span class="n">fileName</span><span class="p">,</span> <span class="n">fileExten</span> <span class="o">=</span> <span class="n">fileInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fileInfo</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">filePath</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">subDir</span><span class="p">,</span> <span class="nb">file</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fileExten</span> <span class="o">==</span> <span class="s">'jpg'</span> <span class="ow">or</span> <span class="n">fileExten</span> <span class="o">==</span> <span class="s">'png'</span> <span class="ow">or</span> <span class="n">fileExten</span> <span class="o">==</span> <span class="s">'.bmp'</span><span class="p">:</span>
            <span class="c1"># if fileExten != 'zip':
</span>                <span class="k">if</span> <span class="n">fileName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fileNameList</span><span class="p">:</span>
                    <span class="n">fileNameList</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
                    <span class="n">filePathList</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filePathList</span>

<span class="c1"># append image path and script to the output csv file
</span><span class="k">def</span> <span class="nf">write_script_to_csv</span><span class="p">(</span><span class="n">imagePath</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">outputFilePath</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputFilePath</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="n">encoding</span> <span class="o">=</span> <span class="s">"utf-8"</span><span class="p">,</span> <span class="n">newline</span> <span class="o">=</span> <span class="s">""</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">newRow</span> <span class="o">=</span> <span class="p">[</span><span class="n">imagePath</span><span class="p">,</span> <span class="n">script</span><span class="p">]</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">newRow</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="main-loop">Main loop</h4>

<p>The main work is done as follows. For each comic page in the root directory, we find the speech bubbles, feed them to Tesseract after some further denoising and processing, obtain the comic script, and write it dynamically to a <code class="language-plaintext highlighter-rouge">.csv</code> file along with the comic page path.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># initialize output file
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputFilePath</span><span class="p">,</span> <span class="s">'w'</span><span class="p">,</span><span class="n">newline</span> <span class="o">=</span> <span class="s">""</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">writer</span><span class="p">.</span><span class="n">writerow</span><span class="p">([</span><span class="s">'filePath'</span><span class="p">,</span> <span class="s">'script'</span><span class="p">])</span>

<span class="c1"># for each image in the given directory, process each speech bubble found and feed it to the ocr engine
</span><span class="k">for</span> <span class="n">imagePath</span> <span class="ow">in</span> <span class="n">looper</span><span class="p">(</span><span class="n">rootDir</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">imagePath</span><span class="p">)</span>
    <span class="c1"># find speech bubbles in each image
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="n">croppedImageList</span> <span class="o">=</span> <span class="n">findSpeechBubbles</span><span class="p">(</span><span class="n">imagePath</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">'simple'</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="n">scriptList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">croppedImage</span> <span class="ow">in</span> <span class="n">croppedImageList</span><span class="p">:</span>
        <span class="c1"># enlarge
</span>        <span class="n">croppedImage</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">croppedImage</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">fx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fy</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># denoise
</span>        <span class="n">croppedImage</span> <span class="o">=</span> <span class="n">denoise</span><span class="p">(</span><span class="n">croppedImage</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">croppedImage</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">dilate</span><span class="p">(</span><span class="n">croppedImage</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">croppedImage</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">erode</span><span class="p">(</span><span class="n">croppedImage</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span>

        <span class="c1"># turn gray
</span>        <span class="n">croppedImageGray</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">croppedImage</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="c1"># Gaussian filter
</span>        <span class="n">croppedImageGrayBlur</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">croppedImageGray</span><span class="p">,(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># edge detection
</span>        <span class="n">croppedImageGrayBlurLaplacian</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">Laplacian</span><span class="p">(</span><span class="n">croppedImageGrayBlur</span><span class="p">,</span><span class="n">cv2</span><span class="p">.</span><span class="n">CV_64F</span><span class="p">)</span>
        <span class="c1"># adjust contrast and brightness
</span>        <span class="n">croppedImageGrayBlurLaplacian</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">clip</span><span class="p">((</span><span class="mi">10</span> <span class="o">*</span> <span class="n">croppedImageGrayBlurLaplacian</span> <span class="o">+</span> <span class="mi">10</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

        <span class="c1"># pass cropped image to the ocr engine
</span>        <span class="n">script</span> <span class="o">=</span> <span class="n">tesseract</span><span class="p">(</span><span class="n">croppedImageGrayBlurLaplacian</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">script</span> <span class="o">!=</span> <span class="s">''</span> <span class="ow">and</span> <span class="n">script</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scriptList</span><span class="p">:</span>
            <span class="n">scriptList</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
            <span class="c1"># append image path and script to the output csv file
</span>            <span class="n">write_script_to_csv</span><span class="p">(</span><span class="n">imagePath</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">outputFilePath</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="result">Result</h3>

<p>The resulting data file looks like this:</p>

<p><img src="/images/ocr-result.png" alt="" width="800px" /></p>

<p>There are still noises, but at least most of the comic script are picked up reasonably well. This is enough for our purpose, since we technically only need a relatively small number of sparsely distributed individual words that are correctly recognized.</p>

<!-- Here is an example of the image message that can be composed from the dictionary built above.

<div style="text-align: center"><img src="/images/comic-ocr-message.png" width="400px" /></div> -->

:ET